install.packages("tidyverse")
library(tidyverse)
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios<- read_csv(file= arquivo)
dados_municipios
filter(.data= dados_municipios, sigla_uf=="PE" )
filter(.data= dados_municipios, sigla_uf=="CE" )
dados_municipios %>%
filter(sigla_uf=="CE")
dados_municipios %>%
filter(sigla_uf=="CE") %>%
filter(populacao > 100000)
dados_municipios %>%
filter(sigla_uf=="CE")
dados_municipios %>%
filter(sigla_uf=="CE") %>%
filter(populacao > 100000)
names(dados_municipios)
dados_municipios%>%
filter(sigla_uf == "CE") %>%
filter(populacao > 100000) %>%
select(sigla_uf,nome, populacao) #indica as colunas que devem aparecer no resultado da sequência de comandos
dados_municipios%>%
filter(sigla_uf == "CE") %>%
filter(populacao > 100000) %>%
select(sigla_uf,nome, populacao) %>% #indica as colunas que devem aparecer no resultado da sequência de comandos
arrange(populacao)
dados_municipios%>%
filter(sigla_uf == "CE") %>%
filter(populacao > 100000) %>%
select(sigla_uf,nome, populacao) %>% #indica as colunas que devem aparecer no resultado da sequência de comandos
arrange(desc(populacao)) #ordenação em ordem decrescente de população
dados_municipios %>%
group_by(sigla_uf) %>% #Agrupa pela variável sigla_uf
summarise(
populacao_estado = sum(populacao) #soma a populacao de todos os municípios
)
dados_municipios %>%
group_by(sigla_uf) %>% #Agrupa pela variável sigla_uf
summarise(
populacao_estado = sum(populacao) #soma a populacao de todos os municípios
) %>%
arrange(desc(populacao_estado)) #faz a ordenação descrescente por populacao_estado
dados_municipios %>%
group_by(sigla_uf) %>% #Agrupa pela variável sigla_uf
summarise(
quantidade_municipios = n() #soma a populacao de todos os municípios
) %>%
arrange(desc(quantidade_municipios)) #faz a ordenação descrescente por populacao_estado
dados_municipios %>%
group_by(sigla_uf) %>% #Agrupa pela variável sigla_uf
summarise(
quantidade_municipios = n(),
populacao_estado = sum(populacao),
media_populacao = mean(populacao),
mediana_populacao = median(populacao)
) %>%
arrange(desc(quantidade_municipios)) #faz a ordenação descrescente por populacao_estado
dados_municipios %>%
mutate(nome_regiao_saude_uf = paste(nome, nome_regiao_saude, sigla_uf, sep = "-")) %>%
select(nome_regiao_saude_uf, populacao)
q()
install.packages("tidyverse")
library(tidyverse)
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios<- read_csv(file= arquivo)
#Na sequência de instruções abaixo geramos um gráfico de colunas com as populações dos municípios pernambucanos com mais de 100 mil habitantes
# no eixo x (horizontal) aparecem as populações e no eixo y (vertical) o nome das cidades
dados_municipios %>%
filter(sigla_uf == "PE") %>%
filter(populacao>100000) %>%
ggplot()+
geom_col(aes(x=populacao, y=nome))
#A função slice_max retorna as n linhas que possuem os maiores valores para uma dada variável
#Veja como podemos usar a função slice_max para mostrar os 10 municípios mais populosos do Brasil
dados_municipios %>%
slice_max(populacao, n=10) %>%
ggplot()+
geom_col(aes(x=populacao, y=nome))
dados_municipios %>%
slice_max(populacao, n=10) %>%
mutate(nome=reorder(nome, populacao)) %>% #reordena a variável nome a partir do valor da variável população
ggplot()+
geom_col(aes(x=populacao, y=nome))
dados_municipios %>%
slice_max(populacao, n=10) %>%
mutate(nome=reorder(nome, populacao)) %>%
ggplot()+
geom_col(aes(x=populacao, y=nome, fill=nome_regiao))
#Instale o pacote dados
install.packages("dados")
library(dados)
library(tidyverse)
dados_gapminder %>%
filter(continente=="Américas") %>%
filter(ano==2007) %>%
ggplot()+
geom_point(aes(x=pib_per_capita, y=expectativa_de_vida))
conjunto_continentes <- c("Américas", "África") #Cria um objeto com o conjunto de continentes a ser usado no filtro
dados_gapminder %>%
filter(continente %in% conjunto_continentes) %>%
filter(ano==2007) %>%
ggplot()+
geom_point(aes(x=pib_per_capita, y=expectativa_de_vida))
dados_gapminder %>%
filter(continente %in% conjunto_continentes) %>%
filter(ano==2007) %>%
ggplot()+
geom_point(aes(x=pib_per_capita, y=expectativa_de_vida, color= continente))
#O gráfico abaixo mostra a evolução da expectativa de vida no Brasil desde o início da série histórica
dados_gapminder %>%
filter(pais == "Brasil") %>%
ggplot()+
geom_line(aes(x=ano, y=expectativa_de_vida ))
dados_gapminder %>%
filter(pais == "Brasil") %>%
ggplot()+
geom_line(aes(x=ano, y=expectativa_de_vida )) +
geom_point(aes(x=ano, y=expectativa_de_vida ))
src refspec master does not match any
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios<- read_csv(file= arquivo)
#para fazer gráficos box-plot usamos a geom_boxplot
dados_municipios%>%
filter(nome_regiao=="Nordeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao))
dados_municipios%>%
filter(nome_regiao=="Nordeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao)) +
scale_y_log10()
dados_municipios%>%
ggplot()+
geom_histogram(aes(x=populacao))
dados_municipios%>%
ggplot()+
geom_histogram(aes(x=populacao), color = "white") +
scale_x_log10()
dados_municipios%>%
ggplot()+
geom_histogram(aes(x=populacao))
dados_municipios%>%
ggplot()+
geom_histogram(aes(x=populacao), color = "white") +
scale_x_log10()
#para fazer gráficos box-plot usamos a geom_boxplot
dados_municipios%>%
filter(nome_regiao=="Nordeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao))
dados_municipios%>%
filter(nome_regiao=="Nordeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao)) +
scale_y_log10()
install.packages("tidyverse")
library(tidyverse)
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios<- read_csv(file= arquivo)
#para fazer gráficos box-plot usamos a geom_boxplot
dados_municipios%>%
filter(nome_regiao=="Nordeste", "Sul", "Norte", "Centro-Oeste", "Sudeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao))
dados_municipios<- read_csv(file= arquivo)
#para fazer gráficos box-plot usamos a geom_boxplot
dados_municipios%>%
filter(nome_regiao=="Nordeste", "Sul", "Norte", "Centro-Oeste", "Sudeste") %>%
ggplot()+
geom_boxplot(aes(x=sigla_uf, y=populacao))
library(tidyverse)
arquivo <- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios <- read_csv(file = arquivo)
# Boxplot da população por região
dados_municipios %>%
ggplot(aes(x = nome_regiao, y = populacao)) +
geom_boxplot() +
scale_y_log10() +
labs(
title = "Distribuição da População dos Municípios por Região",
x = "Região do Brasil",
y = "População (escala log10)"
)
install.packages("tidyverse")
library(tidyverse)
arquivo <- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_municipios.csv"
dados_municipios <- read_csv(file = arquivo)
# Boxplot da população por região
dados_municipios %>%
ggplot(aes(x = nome_regiao, y = populacao)) +
geom_boxplot() +
scale_y_log10() +
labs(
title = "Distribuição da População dos Municípios por Região",
x = "Região do Brasil",
y = "População (escala log10)"
)
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_saude_municipio.csv"
dados_saude_municipio<-
read_csv(file = arquivo)
#Os gráficos de correlação são feitos a partir de gráficos de pontos
#Nos eixos x e y colocamos as variáves que queremos verificar visualmente se há correlação
#No caso do gráfico abaixo queremos testar se há correlação entre população e percentual gasto com saúde
dados_saude_municipio%>%
ggplot()+
geom_point(aes(x=populacao, y=perc))
dados_saude_municipio%>%
ggplot()+
geom_point(aes(x=populacao, y=perc))+
scale_x_log10()
#Para se calcular a correlação entre as duas variáveis usamos a função cor
#Na função indicamos as duas variáveis que queremos checar a correlação
#No gráfico fizemos a transformação logaritimca no eixo x que corresponde à variável população
#O mais indicado é testar a correlação transformando os dados de população usando logarítimo. Para isso usamos a função logcor(log10(dados_saude_municipio$populacao), dados_saude_municipio$perc)
cor(log10(dados_saude_municipio$populacao), dados_saude_municipio$perc)
dados_saude_municipio%>%
ggplot()+
geom_point(aes(x=populacao, y=valor))
dados_saude_municipio%>%
ggplot()+
geom_point(aes(x=populacao, y=valor))+
scale_x_log10() +
scale_y_log10()
#O cálculo da correlação admite a transformação em logaritmo para as duas variáveis
cor(log10(dados_saude_municipio$populacao), log10(dados_saude_municipio$valor))
arquivo<- "https://raw.githubusercontent.com/fernandobarbalho/enap_auto_instucional/main/data/dados_saude_municipio.csv"
cor(municipios_pequenos$populacao, municipios_pequenos$perc)
dados_saude_municipio<- read_csv(file = arquivo)
municipios_pequenos<-
dados_saude_municipio%>%
filter(populacao<20000)
cor(municipios_pequenos$populacao, municipios_pequenos$perc)
install.packages("tidyverse")
library(tidyverse)
#url do dado
url_habitacao<- "http://sishab.mdr.gov.br/dados_abertos/_contratacoes_pcmv_pcva.csv"
#download do dado a partir do endereço da url
download.file(url = url_habitacao, destfile = "contratacoes_pcmv_pcva.csv", mode="wb")
#gera um dataframe a partir do arquivo csv baixado
contratacoes_pcmv_pcva <- read_delim("contratacoes_pcmv_pcva.csv",
delim = "|", escape_double = FALSE, locale = locale(encoding = "LATIN1"),
trim_ws = TRUE) #sugestão: procure ler sobre encoding
contratacoes_pcmv_pcva%>%
group_by(txt_uf) %>%
summarise(
contratadas= sum(qtd_uh_contratadas), #soma das quantidades de unidades habitacionais contratadas
entregues = sum(qtd_uh_entregues), #soma das quantidades de unidades habitacionais entregues
perc_entregues = (entregues/contratadas)*100 #de unidades habitacionais entregues
) %>%
arrange(desc(perc_entregues))
library(tidyverse)
#url do dado
url_habitacao<- "http://sishab.mdr.gov.br/dados_abertos/_contratacoes_pcmv_pcva.csv"
#download do dado a partir do endereço da url
download.file(url = url_habitacao, destfile = "contratacoes_pcmv_pcva.csv", mode="wb")
#download do dado a partir do endereço da url
download.file(url = url_habitacao, destfile = "contratacoes_pcmv_pcva.csv", mode="wb")
install.packages("janitor") #instale o pacote para melhorar a legibilidade dos nomes da tabela
library(tidyverse)
library(janitor)
url_estoque_dpf<- "https://www.tesourotransparente.gov.br/ckan/dataset/0998f610-bc25-4ce3-b32c-a873447500c2/resource/b6280ed3-ef7e-4569-954a-bded97c2c8a1/download/EstoqueDPF.csv"
#lê o arquivo diretamente da url, observe que aqui não precisamos fazer o download do dado
estoque_dpf<- read_csv2(url_estoque_dpf)
#veja os nomes das colunas do dataframe
names(estoque_dpf)
#A função clean_names do pacote janitor deixa o nome das variáveis mais legíveis
estoque_dpf<- janitor::clean_names(estoque_dpf)
#gráfico a partir do agrupamento por tipo de dívida
estoque_dpf %>%
filter(mes_do_estoque=="12/2021") %>% #filtra para permanecer apenas dados de 12/2021
group_by(tipo_de_divida) %>% #agrupa por tipo de dívida (interna/externa)
summarise(
total_divida = sum(valor_do_estoque) #calcula o total da dívida por tipo
) %>%
ggplot()+
geom_col(aes(x=tipo_de_divida,y=total_divida))
install.packages("devtools")
devtools::install_github("tchiluanda/rtn")
library(rtn)
library(tidyverse)
rtn::get_full_account_name()
despesa_beneficios_previdenciarios<- "4.1 Benefícios Previdenciários"
get_account_data_by_month(despesa_beneficios_previdenciarios,month = 12)
dados_previdenciarios<-get_account_data_by_month(despesa_beneficios_previdenciarios,month = 1:12)
dados_previdenciarios%>%
plot_rtn_series()
dados_previdenciarios<-get_account_data_by_month(despesa_beneficios_previdenciarios,month = 1:12)
dados_previdenciarios%>%
plot_rtn_series()
library(rtn)
library(tidyverse)
rtn::get_full_account_name()
despesa_beneficios_previdenciarios<- "4.1 Benefícios Previdenciários"
get_account_data_by_month(despesa_beneficios_previdenciarios,month = 12)
dados_previdenciarios<-get_account_data_by_month(despesa_beneficios_previdenciarios,month = 1:12)
dados_previdenciarios%>%
plot_rtn_series()
get_account_data_by_month(despesa_beneficios_previdenciarios,month = 1:12) %>%
plot_rtn_series()
get_full_account_name()
despesas_obrigatorias<- c("4.4.1.1", "4.4.1.2", "4.4.1.3","4.4.1.4","4.4.1.5" )
get_12_month_accumulated_account_data_by_month(despesas_obrigatorias,
month = c(1:12), #indica que quer o valor acumulado para todos os 12 meses do ano
match_required = FALSE)%>% #indica que vai fazer o match sem precisar do nome completo da conta
plot_rtn_series() #gera o gráfico de linha
#Utilizacao do pacote RCOFOG
#Instala o pacote Rcofog
install.packages("devtools")
install.packages("devtools")
devtools::install_github("tchiluanda/Rcofog")
library(tidyverse)
#Gera um gráfico de fluxo entras funções e sub-funções de governo para o ano de 2020
Rcofog::dataExpenseFlow(year=2020)%>%
Rcofog::graphExpenseFlow()
#Gera um gráfico de fluxo entras funções e sub-funções de governo para o ano de 2020
Rcofog::dataExpenseFlow(year=2020)%>%
Rcofog::graphExpenseFlow()
unlink("/cloud/lib/x86_64-pc-linux-gnu-library/4.5/00LOCK-Rcofog", recursive = TRUE)
q()
